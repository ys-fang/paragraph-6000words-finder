<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‹±æ–‡æ–‡ç« å–®å­—æ¯”å°å·¥å…· (NLPç‰ˆæœ¬ - åœ‹ä¸­2000å­—)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .input-section {
            margin-bottom: 30px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }
        
        .btn-secondary:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .results-section {
            display: none;
        }
        
        .results-section.show {
            display: block;
        }
        
        .table-container {
            overflow-x: auto;
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        tr:hover {
            background: #f8f9ff;
        }
        
        .found {
            color: #4CAF50;
            font-weight: 600;
        }
        
        .not-found {
            color: #ff6b6b;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .filter-section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .filter-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group label {
            margin: 0;
            font-weight: normal;
        }

        .filter-group select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .editable-lemma {
            background: #fff9e6;
            border: 1px solid #ffd966;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 80px;
            font-family: monospace;
        }

        .editable-lemma:focus {
            outline: 2px solid #ff9800;
            background: #ffffff;
        }

        .qa-section {
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #ff9800;
            display: none;
        }

        .qa-section.show {
            display: block;
        }

        .btn-recheck {
            background: #ff9800;
            color: white;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-recheck:hover {
            background: #f57c00;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 152, 0, 0.4);
        }

        .edit-hint {
            color: #e65100;
            font-size: 13px;
            margin-top: 5px;
        }

        .download-section {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4caf50;
        }

        .selection-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin: 15px 0;
            align-items: center;
        }

        .stat-badge {
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .stat-badge.total {
            background: #2196f3;
            color: white;
        }

        .stat-badge.c1200 { background: #e3f2fd; color: #1565c0; }
        .stat-badge.c800 { background: #f3e5f5; color: #6a1b9a; }

        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .btn-quick {
            padding: 6px 12px;
            font-size: 13px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-quick:hover {
            background: #f5f5f5;
            border-color: #999;
        }

        .checkbox-cell {
            text-align: center;
            width: 40px;
        }

        .checkbox-cell input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“š è‹±æ–‡æ–‡ç« å–®å­—æ¯”å°å·¥å…· (NLPç‰ˆæœ¬ - åœ‹ä¸­2000å­—)</h1>
        <p class="subtitle">ä½¿ç”¨ Compromise.js é€²è¡Œæ™ºèƒ½è©å½¢é‚„åŸ | èˆ‡åœ‹ä¸­ 2000 å–®å­—è³‡æ–™è¡¨æ¯”å°åˆ†æ</p>
        
        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196f3;">
            <strong>ğŸ¤– NLP ç‰ˆæœ¬ç‰¹è‰²ï¼š</strong>
            <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                <li>ä½¿ç”¨ Compromise.js è‡ªç„¶èªè¨€è™•ç†åº«é€²è¡Œæ™ºèƒ½è©å½¢é‚„åŸ</li>
                <li>æ›´æº–ç¢ºçš„è©æ€§è­˜åˆ¥ï¼ˆå‹•è©ã€åè©ã€å½¢å®¹è©ç­‰ï¼‰</li>
                <li>é©åˆéœ€è¦é«˜ç²¾åº¦åˆ†æçš„ä½¿ç”¨å ´æ™¯</li>
                <li><a href="index_nlp.html" style="color: #2196f3;">åˆ‡æ›åˆ°é«˜ä¸­ç‰ˆæœ¬</a>ï¼ˆ6000 å–®å­—ï¼‰</li>
            </ul>
        </div>
        
        <div class="input-section">
            <label for="articleInput">è«‹è²¼ä¸Šæ‚¨çš„è‹±æ–‡æ–‡ç« ï¼š</label>
            <textarea id="articleInput" placeholder="åœ¨é€™è£¡è²¼ä¸Šæ‚¨æƒ³è¦åˆ†æçš„è‹±æ–‡æ–‡ç« ..."></textarea>
            <div class="button-group">
                <button class="btn-primary" onclick="analyzeArticle()">ğŸ” é–‹å§‹åˆ†æ</button>
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨åˆ†ææ–‡ç« ...</p>
        </div>
        
        <div class="results-section" id="resultsSection">
            <div class="stats" id="stats"></div>
            
            <div class="qa-section" id="qaSection">
                <strong>ğŸ”§ äººå·¥ QA éšæ®µï¼š</strong>
                <p style="margin: 10px 0;">æ‚¨ç¾åœ¨å¯ä»¥ç·¨è¼¯ã€Œå–®å­—åŸå‹ã€æ¬„ä½ï¼ˆé»ƒè‰²èƒŒæ™¯ï¼‰ä¾†ä¿®æ­£ NLP ç„¡æ³•æ­£ç¢ºè™•ç†çš„è©å½¢ã€‚</p>
                <p class="edit-hint">ğŸ’¡ æç¤ºï¼šé»æ“ŠåŸå‹æ¬„ä½å³å¯ç·¨è¼¯ï¼Œå®Œæˆå¾Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•é‡æ–°æª¢ç´¢</p>
                <button class="btn-recheck" onclick="recheckWithUpdatedLemmas()">ğŸ”„ é‡æ–°æª¢ç´¢ 2000 å–®å­—</button>
            </div>
            
            <div class="download-section" id="downloadSection">
                <strong>ğŸ“¥ ä¸‹è¼‰é¸æ“‡çš„å–®å­—</strong>
                <div class="selection-stats" id="selectionStats">
                    <span class="stat-badge total">ç¸½è¨ˆï¼š0 å€‹</span>
                    <span class="stat-badge c1200">1200ï¼š0</span>
                    <span class="stat-badge c800">800ï¼š0</span>
                </div>
                <div class="quick-actions">
                    <button class="btn-quick" onclick="selectAll()">âœ… å…¨é¸</button>
                    <button class="btn-quick" onclick="deselectAll()">âŒ å–æ¶ˆå…¨é¸</button>
                    <button class="btn-quick" onclick="toggleSelectByLevel('1200')">åˆ‡æ› 1200</button>
                    <button class="btn-quick" onclick="toggleSelectByLevel('800')">åˆ‡æ› 800</button>
                    <button class="btn-quick" onclick="toggleSelectFound()">åˆ‡æ›æ‰¾åˆ°çš„</button>
                    <button class="btn-quick" onclick="toggleSelectNotFound()">åˆ‡æ›æœªæ‰¾åˆ°çš„</button>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn-secondary" id="downloadBtn" onclick="downloadTSV()" disabled>â¬‡ï¸ ä¸‹è¼‰é¸æ“‡çš„å–®å­—ç‚º TSV</button>
                </div>
            </div>
            
            <div class="filter-section">
                <div class="filter-group">
                    <label>ç¯©é¸é¡¯ç¤ºï¼š</label>
                    <select id="filterSelect" onchange="applyFilter()">
                        <option value="all">é¡¯ç¤ºå…¨éƒ¨</option>
                        <option value="found">åªé¡¯ç¤ºæ‰¾åˆ°çš„å–®å­—</option>
                        <option value="notfound">åªé¡¯ç¤ºæœªæ‰¾åˆ°çš„å–®å­—</option>
                    </select>
                </div>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th class="checkbox-cell">
                                <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" title="å…¨é¸/å–æ¶ˆå…¨é¸">
                            </th>
                            <th>åºè™Ÿ</th>
                            <th>æ–‡ç« ä¸­çš„å–®å­—</th>
                            <th>å–®å­—åŸå‹</th>
                            <th>å°æ‡‰æ¨™ç±¤</th>
                            <th>ä¸­è­¯</th>
                            <th>CEFR ç­‰ç´š</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTable"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥ Compromise.js è‡ªç„¶èªè¨€è™•ç†åº« -->
    <script src="https://unpkg.com/compromise"></script>
    <script>
        let vocabularyData = [];
        let analysisResults = [];
        let selectedWords = new Set(); // å„²å­˜å·²é¸æ“‡çš„å–®å­—ç´¢å¼•
        
        // ä½¿ç”¨ Compromise.js é€²è¡Œè©å½¢é‚„åŸ
        function getLemmaWithNLP(word) {
            try {
                const doc = nlp(word);
                
                // å˜—è©¦å‹•è©åŸå‹
                if (doc.verbs().length > 0) {
                    const infinitive = doc.verbs().toInfinitive().out('text').replace(/^to /, '');
                    if (infinitive) return infinitive.toLowerCase();
                }
                
                // å˜—è©¦åè©å–®æ•¸
                if (doc.nouns().length > 0) {
                    const singular = doc.nouns().toSingular().out('text');
                    if (singular) return singular.toLowerCase();
                }
                
                // å˜—è©¦å½¢å®¹è©åŸå‹
                if (doc.adjectives().length > 0) {
                    const base = doc.adjectives().toAdverb().out('text');
                    if (base && base.endsWith('ly')) {
                        return base.slice(0, -2).toLowerCase();
                    }
                }
                
                // å¦‚æœéƒ½æ²’æœ‰ï¼Œè¿”å›åŸå§‹å°å¯«
                return word.toLowerCase();
            } catch (error) {
                console.error('NLP è™•ç†éŒ¯èª¤:', error);
                return word.toLowerCase();
            }
        }
        
        // è¼‰å…¥ 2000 å–®å­—è³‡æ–™
        async function loadVocabularyData() {
            try {
                const response = await fetch('2000-1200-800words.tsv');
                const text = await response.text();
                const lines = text.split('\n');
                
                vocabularyData = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const parts = line.split('\t');
                    
                    // è‡³å°‘éœ€è¦ 4 å€‹æ¬„ä½ï¼šlabel, word, pronunciation, translation
                    // ç¬¬ 11 å€‹æ¬„ä½ï¼ˆç´¢å¼• 10ï¼‰æ˜¯ CEFR ç­‰ç´šï¼Œå¯èƒ½ä¸å­˜åœ¨
                    if (parts.length >= 4) {
                        const word = parts[1].toLowerCase().trim();
                        
                        // è™•ç†å¤šç¨®æ ¼å¼ï¼š
                        // 1. "a/an" -> ["a", "an"]
                        // 2. "enjoy(ment)" -> ["enjoy", "enjoyment"]
                        // 3. "dance (dancing)" -> ["dance", "dancing"]
                        // 4. "actor/actress" -> ["actor", "actress"]
                        const words = [];
                        
                        // å…ˆè™•ç†æ–œç·šåˆ†å‰²
                        const slashParts = word.split('/').map(w => w.trim());
                        slashParts.forEach(part => {
                            // è™•ç†æ‹¬è™Ÿï¼ˆæ”¯æ´æ‹¬è™Ÿå‰æœ‰ç©ºæ ¼çš„æƒ…æ³ï¼‰
                            // åŒ¹é… "word (variant)" æˆ– "word(variant)" æ ¼å¼
                            const parenMatch = part.match(/^([^()]+)\s*\(([^)]+)\)$/);
                            if (parenMatch) {
                                const base = parenMatch[1].trim(); // "dance" æˆ– "enjoy"
                                const variant = parenMatch[2].trim(); // "dancing" æˆ– "ment"
                                
                                // å¦‚æœ variant æ˜¯å®Œæ•´å–®å­—ï¼ˆå¦‚ "dancing"ï¼‰ï¼Œç›´æ¥åŠ å…¥
                                // å¦‚æœ variant æ˜¯å¾Œç¶´ï¼ˆå¦‚ "ment"ï¼‰ï¼Œçµ„åˆå¾ŒåŠ å…¥
                                words.push(base); // "dance" æˆ– "enjoy"
                                
                                // åˆ¤æ–· variant æ˜¯å¦ç‚ºå®Œæ•´å–®å­—ï¼ˆåŒ…å«å­—æ¯ä¸”å¯èƒ½ç¨ç«‹å­˜åœ¨ï¼‰
                                if (variant.match(/^[a-z]+$/)) {
                                    // å®Œæ•´å–®å­—ï¼Œç›´æ¥åŠ å…¥
                                    words.push(variant); // "dancing"
                                } else {
                                    // å¾Œç¶´ï¼Œçµ„åˆå¾ŒåŠ å…¥
                                    words.push(base + variant); // "enjoyment"
                                }
                            } else {
                                words.push(part);
                            }
                        });
                        
                        words.forEach(w => {
                            if (w) {
                                vocabularyData.push({
                                    label: parts[0] || '',
                                    word: w,
                                    pronunciation: parts[2] || '',
                                    translation: parts[3] || '',
                                    example: parts[4] || '',
                                    example_translation: parts[5] || '',
                                    related_video: parts[6] || '',
                                    mark_start: parts[7] || '',
                                    mark_end: parts[8] || '',
                                    syllables: parts[9] || '',
                                    cefr: parts[10] || ''
                                });
                            }
                        });
                    }
                }
                console.log(`å·²è¼‰å…¥ ${vocabularyData.length} å€‹å–®å­—`);
            } catch (error) {
                console.error('è¼‰å…¥è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('ç„¡æ³•è¼‰å…¥å–®å­—è³‡æ–™è¡¨ï¼Œè«‹ç¢ºèª 2000-1200-800words.tsv æª”æ¡ˆå­˜åœ¨ï¼');
            }
        }
        
        // å¾è³‡æ–™è¡¨ä¸­æŸ¥æ‰¾å–®å­—
        function findInVocabulary(word) {
            const lowerWord = word.toLowerCase();
            return vocabularyData.find(item => item.word === lowerWord);
        }
        
        // åˆ†ææ–‡ç« 
        async function analyzeArticle() {
            const article = document.getElementById('articleInput').value.trim();
            
            if (!article) {
                alert('è«‹å…ˆè¼¸å…¥æ–‡ç« å…§å®¹ï¼');
                return;
            }
            
            // å¦‚æœå°šæœªè¼‰å…¥è³‡æ–™ï¼Œå…ˆè¼‰å…¥
            if (vocabularyData.length === 0) {
                await loadVocabularyData();
            }
            
            // é¡¯ç¤ºè¼‰å…¥ä¸­
            document.getElementById('loading').classList.add('show');
            document.getElementById('resultsSection').classList.remove('show');
            
            // ä½¿ç”¨ setTimeout è®“ UI æœ‰æ™‚é–“æ›´æ–°
            setTimeout(() => {
                processArticle(article);
            }, 100);
        }
        
        function processArticle(article) {
            // ä½¿ç”¨ Compromise.js é€²è¡Œè‡ªç„¶èªè¨€è™•ç†
            const doc = nlp(article);
            
            // æå–æ‰€æœ‰ termsï¼ˆå–®å­—ï¼‰
            const terms = doc.terms().out('array');
            
            analysisResults = [];
            const processedWords = new Set();
            
            terms.forEach(term => {
                // æ¸…ç†å–®å­—ï¼ˆç§»é™¤æ¨™é»ç¬¦è™Ÿï¼‰
                const cleanWord = term.replace(/[^\w]/g, '');
                if (!cleanWord || processedWords.has(cleanWord.toLowerCase())) {
                    return;
                }
                
                processedWords.add(cleanWord.toLowerCase());
                
                // ä½¿ç”¨ Compromise ç²å–åŸå‹
                const lemma = getLemmaWithNLP(cleanWord);
                
                // åœ¨è³‡æ–™è¡¨ä¸­æŸ¥æ‰¾ï¼ˆå…ˆæŸ¥åŸå‹ï¼Œå†æŸ¥åŸå§‹å–®å­—ï¼‰
                const found = findInVocabulary(lemma) || findInVocabulary(cleanWord);
                
                analysisResults.push({
                    original: cleanWord,
                    lemma: lemma,
                    label: found ? found.label : 'æœªæ‰¾åˆ°',
                    translation: found ? found.translation : '-',
                    cefr: found ? found.cefr : '-',
                    found: !!found,
                    selected: false, // é è¨­ä¸é¸æ“‡
                    // ä¿å­˜å®Œæ•´æ¬„ä½ä»¥ä¾›ä¸‹è¼‰
                    fullData: found ? {
                        pronunciation: found.pronunciation,
                        example: found.example,
                        example_translation: found.example_translation,
                        related_video: found.related_video,
                        mark_start: found.mark_start,
                        mark_end: found.mark_end,
                        syllables: found.syllables
                    } : null
                });
            });
            
            displayResults();
        }
        
        // é¡¯ç¤ºçµæœ
        function displayResults() {
            document.getElementById('loading').classList.remove('show');
            document.getElementById('resultsSection').classList.add('show');
            document.getElementById('qaSection').classList.add('show');
            
            // é¡¯ç¤ºçµ±è¨ˆè³‡æ–™
            const foundCount = analysisResults.filter(r => r.found).length;
            const notFoundCount = analysisResults.length - foundCount;
            const percentage = analysisResults.length > 0 
                ? ((foundCount / analysisResults.length) * 100).toFixed(1) 
                : 0;
            
            document.getElementById('stats').innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${analysisResults.length}</div>
                    <div class="stat-label">ç¸½å–®å­—æ•¸</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${foundCount}</div>
                    <div class="stat-label">æ‰¾åˆ°çš„å–®å­—</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${notFoundCount}</div>
                    <div class="stat-label">æœªæ‰¾åˆ°çš„å–®å­—</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${percentage}%</div>
                    <div class="stat-label">æ¶µè“‹ç‡</div>
                </div>
            `;
            
            // é¡¯ç¤ºè¡¨æ ¼
            renderTable(analysisResults);
            
            // æ›´æ–°é¸æ“‡çµ±è¨ˆ
            updateSelectionStats();
            
            // é‡è¨­ç¯©é¸å™¨
            document.getElementById('filterSelect').value = 'all';
            
            // é‡è¨­å…¨é¸checkbox
            document.getElementById('selectAllCheckbox').checked = false;
        }
        
        // æå–ç°¡åŒ–æ¨™ç±¤ï¼ˆä¾‹å¦‚ï¼š1200-Holidays-festivals -> 1200ï¼‰
        function getSimplifiedLabel(label) {
            if (!label || label === 'æœªæ‰¾åˆ°') return label;
            
            // æå–é–‹é ­çš„æ•¸å­—ï¼ˆä¾‹å¦‚ï¼š1200-Holidays-festivals -> 1200ï¼‰
            const match = label.match(/^(\d+)/);
            if (match) {
                return match[1];
            }
            
            return label;
        }
        
        // æ¸²æŸ“è¡¨æ ¼
        function renderTable(data) {
            const tbody = document.getElementById('resultsTable');
            tbody.innerHTML = '';
            
            data.forEach((result, index) => {
                const row = document.createElement('tr');
                const statusClass = result.found ? 'found' : 'not-found';
                
                // æ‰¾åˆ°åœ¨ analysisResults ä¸­çš„å¯¦éš›ç´¢å¼•
                const actualIndex = analysisResults.findIndex(r => 
                    r.original === result.original && r.lemma === result.lemma
                );
                
                // ç°¡åŒ–æ¨™ç±¤é¡¯ç¤º
                const displayLabel = getSimplifiedLabel(result.label);
                
                row.innerHTML = `
                    <td class="checkbox-cell">
                        <input type="checkbox" 
                               ${result.selected ? 'checked' : ''}
                               onchange="toggleWordSelection(${actualIndex})"
                               title="é¸æ“‡æ­¤å–®å­—">
                    </td>
                    <td>${index + 1}</td>
                    <td>${result.original}</td>
                    <td>
                        <input type="text" 
                               class="editable-lemma" 
                               value="${result.lemma}"
                               data-index="${actualIndex}"
                               onchange="updateLemma(${actualIndex}, this.value)"
                               title="é»æ“Šç·¨è¼¯åŸå‹">
                    </td>
                    <td class="${statusClass}" title="${result.label}">${displayLabel}</td>
                    <td>${result.translation}</td>
                    <td>${result.cefr}</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // åˆ‡æ›å–®å­—é¸æ“‡
        function toggleWordSelection(index) {
            if (index >= 0 && index < analysisResults.length) {
                analysisResults[index].selected = !analysisResults[index].selected;
                updateSelectionStats();
            }
        }
        
        // æ›´æ–°é¸æ“‡çµ±è¨ˆ
        function updateSelectionStats() {
            const selected = analysisResults.filter(r => r.selected);
            const total = selected.length;
            
            // å‹•æ…‹æ”¶é›†æ‰€æœ‰é¡åˆ¥
            const levelCounts = {};
            
            selected.forEach(result => {
                const level = getSimplifiedLabel(result.label);
                if (level !== 'æœªæ‰¾åˆ°') {
                    if (!levelCounts[level]) {
                        levelCounts[level] = 0;
                    }
                    levelCounts[level]++;
                }
            });
            
            // ç”Ÿæˆçµ±è¨ˆå¾½ç«  HTML
            let statsHTML = `<span class="stat-badge total">ç¸½è¨ˆï¼š${total} å€‹</span>`;
            
            // å›ºå®šé¡¯ç¤º 1200 å’Œ 800
            const count1200 = levelCounts['1200'] || 0;
            const count800 = levelCounts['800'] || 0;
            
            statsHTML += `<span class="stat-badge c1200">1200ï¼š${count1200}</span>`;
            statsHTML += `<span class="stat-badge c800">800ï¼š${count800}</span>`;
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('selectionStats').innerHTML = statsHTML;
            
            // æ›´æ–°ä¸‹è¼‰æŒ‰éˆ•ç‹€æ…‹
            document.getElementById('downloadBtn').disabled = (total === 0);
        }
        
        // å…¨é¸
        function selectAll() {
            analysisResults.forEach(r => r.selected = true);
            renderTable(analysisResults);
            updateSelectionStats();
            document.getElementById('selectAllCheckbox').checked = true;
        }
        
        // å–æ¶ˆå…¨é¸
        function deselectAll() {
            analysisResults.forEach(r => r.selected = false);
            renderTable(analysisResults);
            updateSelectionStats();
            document.getElementById('selectAllCheckbox').checked = false;
        }
        
        // æ¨™é¡Œåˆ—çš„å…¨é¸/å–æ¶ˆå…¨é¸
        function toggleSelectAll() {
            const checkbox = document.getElementById('selectAllCheckbox');
            if (checkbox.checked) {
                selectAll();
            } else {
                deselectAll();
            }
        }
        
        // åˆ‡æ›ç­‰ç´šé¸æ“‡ï¼ˆè¤‡é¸æ¨¡å¼ï¼‰
        function toggleSelectByLevel(level) {
            // æª¢æŸ¥è©²ç­‰ç´šæ˜¯å¦å…¨éƒ¨å·²é¸
            const levelWords = analysisResults.filter(result => getSimplifiedLabel(result.label) === level);
            const allSelected = levelWords.length > 0 && levelWords.every(result => result.selected);
            
            // å¦‚æœå…¨éƒ¨å·²é¸ï¼Œå‰‡å–æ¶ˆé¸æ“‡ï¼›å¦å‰‡å…¨éƒ¨é¸ä¸Š
            analysisResults.forEach(result => {
                if (getSimplifiedLabel(result.label) === level) {
                    result.selected = !allSelected;
                }
            });
            renderTable(analysisResults);
            updateSelectionStats();
        }
        
        // åˆ‡æ›ã€Œæ‰¾åˆ°çš„ã€é¸æ“‡ç‹€æ…‹ï¼ˆè¤‡é¸æ¨¡å¼ï¼‰
        function toggleSelectFound() {
            const foundWords = analysisResults.filter(result => result.found);
            const allSelected = foundWords.length > 0 && foundWords.every(result => result.selected);
            
            analysisResults.forEach(result => {
                if (result.found) {
                    result.selected = !allSelected;
                }
            });
            renderTable(analysisResults);
            updateSelectionStats();
        }
        
        // åˆ‡æ›ã€Œæœªæ‰¾åˆ°çš„ã€é¸æ“‡ç‹€æ…‹ï¼ˆè¤‡é¸æ¨¡å¼ï¼‰
        function toggleSelectNotFound() {
            const notFoundWords = analysisResults.filter(result => !result.found);
            const allSelected = notFoundWords.length > 0 && notFoundWords.every(result => result.selected);
            
            analysisResults.forEach(result => {
                if (!result.found) {
                    result.selected = !allSelected;
                }
            });
            renderTable(analysisResults);
            updateSelectionStats();
        }
        
        // æ›´æ–°åŸå‹
        function updateLemma(index, newLemma) {
            if (index >= 0 && index < analysisResults.length) {
                analysisResults[index].lemma = newLemma.toLowerCase().trim();
                console.log(`å·²æ›´æ–°ç´¢å¼• ${index} çš„åŸå‹ç‚º: ${analysisResults[index].lemma}`);
            }
        }
        
        // é‡æ–°æª¢ç´¢ 2000 å–®å­—
        function recheckWithUpdatedLemmas() {
            if (analysisResults.length === 0) {
                alert('æ²’æœ‰è³‡æ–™å¯ä»¥é‡æ–°æª¢ç´¢ï¼');
                return;
            }
            
            // é¡¯ç¤ºè¼‰å…¥ä¸­
            document.getElementById('loading').classList.add('show');
            document.getElementById('resultsSection').classList.remove('show');
            
            setTimeout(() => {
                let recheckCount = 0;
                
                // é‡æ–°æª¢ç´¢æ¯å€‹å–®å­—
                analysisResults.forEach(result => {
                    // ä½¿ç”¨æ›´æ–°å¾Œçš„ lemma é‡æ–°æŸ¥æ‰¾
                    const found = findInVocabulary(result.lemma) || findInVocabulary(result.original);
                    
                    if (found) {
                        // è¨˜éŒ„æ˜¯å¦å¾æœªæ‰¾åˆ°è®Šç‚ºæ‰¾åˆ°
                        if (!result.found) recheckCount++;
                        
                        result.label = found.label;
                        result.translation = found.translation;
                        result.cefr = found.cefr;
                        result.found = true;
                        // æ›´æ–°å®Œæ•´æ¬„ä½
                        result.fullData = {
                            pronunciation: found.pronunciation,
                            example: found.example,
                            example_translation: found.example_translation,
                            related_video: found.related_video,
                            mark_start: found.mark_start,
                            mark_end: found.mark_end,
                            syllables: found.syllables
                        };
                    } else {
                        result.label = 'æœªæ‰¾åˆ°';
                        result.translation = '-';
                        result.cefr = '-';
                        result.found = false;
                        result.fullData = null;
                    }
                });
                
                // é¡¯ç¤ºçµæœ
                displayResults();
                
                // é¡¯ç¤ºé‡æ–°æª¢ç´¢çš„çµ±è¨ˆ
                if (recheckCount > 0) {
                    alert(`âœ… é‡æ–°æª¢ç´¢å®Œæˆï¼\næ–°æ‰¾åˆ° ${recheckCount} å€‹å–®å­—`);
                } else {
                    alert('âœ… é‡æ–°æª¢ç´¢å®Œæˆï¼');
                }
            }, 100);
        }
        
        // æ‡‰ç”¨ç¯©é¸å™¨
        function applyFilter() {
            const filter = document.getElementById('filterSelect').value;
            let filteredData = analysisResults;
            
            if (filter === 'found') {
                filteredData = analysisResults.filter(r => r.found);
            } else if (filter === 'notfound') {
                filteredData = analysisResults.filter(r => !r.found);
            }
            
            renderTable(filteredData);
        }
        
        // ä¸‹è¼‰ TSVï¼ˆåªä¸‹è¼‰é¸æ“‡çš„å–®å­—ï¼‰
        function downloadTSV() {
            const selectedResults = analysisResults.filter(r => r.selected);
            
            if (selectedResults.length === 0) {
                alert('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹å–®å­—ï¼');
                return;
            }
            
            // å»ºç«‹ TSV å…§å®¹ - ä½¿ç”¨èˆ‡ 2000-1200-800words.tsv ç›¸åŒçš„æ¬„ä½çµæ§‹
            let tsvContent = 'æ–‡ç« ä¸­çš„å–®å­—\tå–®å­—åŸå‹\tLabel\tè‹±æ–‡\téŸ³æ¨™\tä¸­è­¯\tä¾‹å¥\tç¿»è­¯\tç›¸é—œå½±ç‰‡\tmark_start\tmark_end\tsyllables\tmain_cefr_label\n';
            
            selectedResults.forEach(result => {
                if (result.found && result.fullData) {
                    // æ‰¾åˆ°çš„å–®å­—ï¼šåŒ…å«å®Œæ•´æ¬„ä½
                    tsvContent += `${result.original}\t${result.lemma}\t${result.label}\t${result.lemma}\t${result.fullData.pronunciation}\t${result.translation}\t${result.fullData.example}\t${result.fullData.example_translation}\t${result.fullData.related_video}\t${result.fullData.mark_start}\t${result.fullData.mark_end}\t${result.fullData.syllables}\t${result.cefr}\n`;
                } else {
                    // æœªæ‰¾åˆ°çš„å–®å­—ï¼šå¡«å…¥ç©ºç™½æ¬„ä½
                    tsvContent += `${result.original}\t${result.lemma}\tæœªæ‰¾åˆ°\t${result.lemma}\t\t\t\t\t\t\t\t\t\n`;
                }
            });
            
            // å»ºç«‹ä¸‹è¼‰é€£çµ
            const blob = new Blob(['\ufeff' + tsvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.setAttribute('href', url);
            link.setAttribute('download', `å–®å­—åˆ†æçµæœ_å·²é¸æ“‡_${timestamp}.tsv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            alert(`âœ… å·²ä¸‹è¼‰ ${selectedResults.length} å€‹é¸æ“‡çš„å–®å­—ï¼`);
        }
        
        // é é¢è¼‰å…¥æ™‚é å…ˆè¼‰å…¥è³‡æ–™
        window.addEventListener('load', () => {
            loadVocabularyData();
        });
    </script>
</body>
</html>

